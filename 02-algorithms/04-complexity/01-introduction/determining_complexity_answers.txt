1. O(1) because it is a constant complexity which means it always takes the same amount of time to execute regardless of the size of the array.
2. O(n) because it is a linear time complexity which means as the array grows in size the number of operations it executes also grows at the same rate.
3. O(n) same as before because it does takes an extra step with having a sub-collection of collections but in the end it will still come out linear complexity.
4. O(2^n) because it will double the time with each additional element. Exponential time.
5. O(n) because in the binary iterative each number is looked over.
6. O(n log n) because similar to merge sort...quick sort it has to pivot through each item to sort it then place them weather they are before or after the pivot point it will take a little while.
